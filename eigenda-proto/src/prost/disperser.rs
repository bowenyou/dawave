// @generated
// Requests and Responses

// Authenicated Message Types

#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticatedRequest {
    #[prost(oneof="authenticated_request::Payload", tags="1, 2")]
    pub payload: ::core::option::Option<authenticated_request::Payload>,
}
/// Nested message and enum types in `AuthenticatedRequest`.
pub mod authenticated_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag="1")]
        DisperseRequest(super::DisperseBlobRequest),
        #[prost(message, tag="2")]
        AuthenticationData(super::AuthenticationData),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticatedReply {
    #[prost(oneof="authenticated_reply::Payload", tags="1, 2")]
    pub payload: ::core::option::Option<authenticated_reply::Payload>,
}
/// Nested message and enum types in `AuthenticatedReply`.
pub mod authenticated_reply {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag="1")]
        BlobAuthHeader(super::BlobAuthHeader),
        #[prost(message, tag="2")]
        DisperseReply(super::DisperseBlobReply),
    }
}
/// BlobAuthHeader contains information about the blob for the client to verify and sign.
/// - Once payments are enabled, the BlobAuthHeader will contain the KZG commitment to the blob, which the client
/// will verify and sign. Having the client verify the KZG commitment instead of calculating it avoids
/// the need for the client to have the KZG structured reference string (SRS), which can be large.
/// The signed KZG commitment prevents the disperser from sending a different blob to the DA Nodes
/// than the one the client sent.
/// - In the meantime, the BlobAuthHeader contains a simple challenge parameter is used to prevent
/// replay attacks in the event that a signature is leaked.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlobAuthHeader {
    #[prost(uint32, tag="1")]
    pub challenge_parameter: u32,
}
/// AuthenticationData contains the signature of the BlobAuthHeader.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AuthenticationData {
    #[prost(bytes="vec", tag="1")]
    pub authentication_data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisperseBlobRequest {
    /// The data to be dispersed.
    /// The size of data must be <= 2MiB. Every 32 bytes of data chunk is interpreted as an integer in big endian format
    /// where the lower address has more significant bits. The integer must stay in the valid range to be interpreted
    /// as a field element on the bn254 curve. The valid range is 
    /// 0 <= x < 21888242871839275222246405745257275088548364400416034343698204186575808495617
    /// containing slightly less than 254 bits and more than 253 bits. If any one of the 32 bytes chunk is outside the range, 
    /// the whole request is deemed as invalid, and rejected. 
    #[prost(bytes="vec", tag="1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// The quorums to which the blob will be sent, in addition to the required quorums which are configured
    /// on the EigenDA smart contract. If required quorums are included here, an error will be returned.
    /// The disperser will ensure that the encoded blobs for each quorum are all processed
    /// within the same batch.
    #[prost(uint32, repeated, tag="2")]
    pub custom_quorum_numbers: ::prost::alloc::vec::Vec<u32>,
    /// The account ID of the client. This should be a hex-encoded string of the ECSDA public key
    /// corresponding to the key used by the client to sign the BlobAuthHeader.
    #[prost(string, tag="3")]
    pub account_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DisperseBlobReply {
    /// The status of the blob associated with the request_id.
    #[prost(enumeration="BlobStatus", tag="1")]
    pub result: i32,
    /// The request ID generated by the disperser.
    /// Once a request is accepted (although not processed), a unique request ID will be
    /// generated.
    /// Two different DisperseBlobRequests (determined by the hash of the DisperseBlobRequest)
    /// will have different IDs, and the same DisperseBlobRequest sent repeatedly at different
    /// times will also have different IDs.
    /// The client should use this ID to query the processing status of the request (via
    /// the GetBlobStatus API).
    #[prost(bytes="vec", tag="2")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
/// BlobStatusRequest is used to query the status of a blob.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlobStatusRequest {
    #[prost(bytes="vec", tag="1")]
    pub request_id: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlobStatusReply {
    /// The status of the blob.
    #[prost(enumeration="BlobStatus", tag="1")]
    pub status: i32,
    /// The blob info needed for clients to confirm the blob against the EigenDA contracts.
    #[prost(message, optional, tag="2")]
    pub info: ::core::option::Option<BlobInfo>,
}
/// RetrieveBlobRequest contains parameters to retrieve the blob.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveBlobRequest {
    #[prost(bytes="vec", tag="1")]
    pub batch_header_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag="2")]
    pub blob_index: u32,
}
/// RetrieveBlobReply contains the retrieved blob data
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RetrieveBlobReply {
    #[prost(bytes="vec", tag="1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
// Types below correspond to the types necessary to verify a blob
// <https://github.com/Layr-Labs/eigenda/blob/master/contracts/src/libraries/EigenDABlobUtils.sol#L29>

/// BlobInfo contains information needed to confirm the blob against the EigenDA contracts
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlobInfo {
    #[prost(message, optional, tag="1")]
    pub blob_header: ::core::option::Option<BlobHeader>,
    #[prost(message, optional, tag="2")]
    pub blob_verification_proof: ::core::option::Option<BlobVerificationProof>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlobHeader {
    /// KZG commitment of the blob.
    #[prost(message, optional, tag="1")]
    pub commitment: ::core::option::Option<super::common::G1Commitment>,
    /// The length of the blob in symbols (each symbol is 32 bytes).
    #[prost(uint32, tag="2")]
    pub data_length: u32,
    /// The params of the quorums that this blob participates in.
    #[prost(message, repeated, tag="3")]
    pub blob_quorum_params: ::prost::alloc::vec::Vec<BlobQuorumParam>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlobQuorumParam {
    /// The ID of the quorum.
    #[prost(uint32, tag="1")]
    pub quorum_number: u32,
    /// The max percentage of stake within the quorum that can be held by or delegated
    /// to adversarial operators. Currently, this and the next parameter are standardized
    /// across the quorum using values read from the EigenDA contracts.
    #[prost(uint32, tag="2")]
    pub adversary_threshold_percentage: u32,
    /// The min percentage of stake that must attest in order to consider
    /// the dispersal is successful.
    #[prost(uint32, tag="3")]
    pub confirmation_threshold_percentage: u32,
    /// The length of each chunk.
    #[prost(uint32, tag="4")]
    pub chunk_length: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlobVerificationProof {
    /// batch_id is an incremental ID assigned to a batch by EigenDAServiceManager
    #[prost(uint32, tag="1")]
    pub batch_id: u32,
    /// The index of the blob in the batch (which is logically an ordered list of blobs).
    #[prost(uint32, tag="2")]
    pub blob_index: u32,
    #[prost(message, optional, tag="3")]
    pub batch_metadata: ::core::option::Option<BatchMetadata>,
    /// inclusion_proof is a merkle proof for a blob header's inclusion in a batch
    #[prost(bytes="vec", tag="4")]
    pub inclusion_proof: ::prost::alloc::vec::Vec<u8>,
    /// indexes of quorums in BatchHeader.quorum_numbers that match the quorums in BlobHeader.blob_quorum_params
    /// Ex. BlobHeader.blob_quorum_params = [
    /// 	{
    /// 		quorum_number = 0,
    /// 		...
    /// 	},
    /// 	{
    /// 		quorum_number = 3,
    /// 		...
    /// 	},
    /// 	{
    /// 		quorum_number = 5,
    /// 		...
    /// 	},
    /// ]
    /// BatchHeader.quorum_numbers = \[0, 5, 3\] => 0x000503
    /// Then, quorum_indexes = \[0, 2, 1\] => 0x000201
    #[prost(bytes="vec", tag="5")]
    pub quorum_indexes: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchMetadata {
    #[prost(message, optional, tag="1")]
    pub batch_header: ::core::option::Option<BatchHeader>,
    /// The hash of all public keys of the operators that did not sign the batch.
    #[prost(bytes="vec", tag="2")]
    pub signatory_record_hash: ::prost::alloc::vec::Vec<u8>,
    /// The fee payment paid by users for dispersing this batch. It's the bytes
    /// representation of a big.Int value.
    #[prost(bytes="vec", tag="3")]
    pub fee: ::prost::alloc::vec::Vec<u8>,
    /// The Ethereum block number at which the batch is confirmed onchain.
    #[prost(uint32, tag="4")]
    pub confirmation_block_number: u32,
    /// This is the hash of the ReducedBatchHeader defined onchain, see:
    /// <https://github.com/Layr-Labs/eigenda/blob/master/contracts/src/interfaces/IEigenDAServiceManager.sol#L43>
    /// The is the message that the operators will sign their signatures on.
    #[prost(bytes="vec", tag="5")]
    pub batch_header_hash: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchHeader {
    /// The root of the merkle tree with the hashes of blob headers as leaves.
    #[prost(bytes="vec", tag="1")]
    pub batch_root: ::prost::alloc::vec::Vec<u8>,
    /// All quorums associated with blobs in this batch. Sorted in ascending order.
    /// Ex. \[0, 2, 1\] => 0x000102
    #[prost(bytes="vec", tag="2")]
    pub quorum_numbers: ::prost::alloc::vec::Vec<u8>,
    /// The percentage of stake that has signed for this batch.
    /// The quorum_signed_percentages\[i\] is percentage for the quorum_numbers\[i\].
    #[prost(bytes="vec", tag="3")]
    pub quorum_signed_percentages: ::prost::alloc::vec::Vec<u8>,
    /// The Ethereum block number at which the batch was created.
    /// The Disperser will encode and disperse the blobs based on the onchain info
    /// (e.g. operator stakes) at this block number.
    #[prost(uint32, tag="4")]
    pub reference_block_number: u32,
}
// Data Types

/// BlobStatus represents the status of a blob.
/// The status of a blob is updated as the blob is processed by the disperser.
/// The status of a blob can be queried by the client using the GetBlobStatus API.
/// Intermediate states are states that the blob can be in while being processed, and it can be updated to a differet state:
/// - PROCESSING
/// - DISPERSING
/// - CONFIRMED
/// Terminal states are states that will not be updated to a different state:
/// - FAILED
/// - FINALIZED
/// - INSUFFICIENT_SIGNATURES
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum BlobStatus {
    Unknown = 0,
    /// PROCESSING means that the blob is currently being processed by the disperser
    Processing = 1,
    /// CONFIRMED means that the blob has been dispersed to DA Nodes and the dispersed
    /// batch containing the blob has been confirmed onchain
    Confirmed = 2,
    /// FAILED means that the blob has failed permanently (for reasons other than insufficient
    /// signatures, which is a separate state)
    Failed = 3,
    /// FINALIZED means that the block containing the blob's confirmation transaction has been finalized on Ethereum
    Finalized = 4,
    /// INSUFFICIENT_SIGNATURES means that the confirmation threshold for the blob was not met
    /// for at least one quorum.
    InsufficientSignatures = 5,
    /// DISPERSING means that the blob is currently being dispersed to DA Nodes and being confirmed onchain
    Dispersing = 6,
}
impl BlobStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            BlobStatus::Unknown => "UNKNOWN",
            BlobStatus::Processing => "PROCESSING",
            BlobStatus::Confirmed => "CONFIRMED",
            BlobStatus::Failed => "FAILED",
            BlobStatus::Finalized => "FINALIZED",
            BlobStatus::InsufficientSignatures => "INSUFFICIENT_SIGNATURES",
            BlobStatus::Dispersing => "DISPERSING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN" => Some(Self::Unknown),
            "PROCESSING" => Some(Self::Processing),
            "CONFIRMED" => Some(Self::Confirmed),
            "FAILED" => Some(Self::Failed),
            "FINALIZED" => Some(Self::Finalized),
            "INSUFFICIENT_SIGNATURES" => Some(Self::InsufficientSignatures),
            "DISPERSING" => Some(Self::Dispersing),
            _ => None,
        }
    }
}
include!("disperser.tonic.rs");
// @@protoc_insertion_point(module)